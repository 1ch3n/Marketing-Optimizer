# -*- coding: utf-8 -*-
"""Copy of auto_report_read_file.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1atsuci_NBLoz6duuXbpEwM62MD0fRK8i
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import ipywidgets as widgets
from ipywidgets import interact, interactive, fixed, interact_manual
import csv
from numpy import mean, std, absolute
from sklearn import metrics
from sklearn.model_selection import cross_val_score, TimeSeriesSplit

from sklearn.model_selection import train_test_split
from sklearn.utils.validation import check_is_fitted, check_array

import statsmodels.tsa.api as tsa
import statsmodels.api as sm

import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.io as pio
import plotly.express as px

from scipy.optimize import minimize
from scipy.stats import trim_mean

from datetime import datetime
from sklearn.metrics import accuracy_score
import random
random.seed(42)

def data_reader(pathname):
    with open(pathname, 'r') as file:
        first_line = file.readline()
        dialect = csv.Sniffer().sniff(first_line)
        sep = dialect.delimiter

    df = pd.read_csv(pathname, sep=sep)
    df['date'] = pd.to_datetime(df['date'])
    first_session_peak = '2023-08-07'
    df = df[df['date'] >= first_session_peak]
    df['conversions_reset'] = [1 if x >= 1 else x for x in df['conversions_reset']]
    return df

def set_dummy_for_date(df, target_date_sports, target_date_festival):
    # Set the dummy variable
    # Set the dummy variable for dutch_sports_event
    df['dutch_sports_event'] = df.apply(lambda row: 1 if row['date'] == target_date_sports else row['dutch_sports_event'], axis=1)

    # Set the dummy variable for dutch_hol_fest
    df['dutch_hol_fest'] = df.apply(lambda row: 1 if row['date'] == target_date_festival else row['dutch_hol_fest'], axis=1)
    return df

def build_model_ols_rf(data, KPI, budget, min_ShoppingReset, min_ResetSearch, min_ResetAfterDrinkSearch):
    import seaborn as sns
    X = data[['ResetSearch_branding_spend','ResetAfterDrinkSearch_branding_spend','ShoppingReset_spend','quarter_1',
            'quarter_2', 'quarter_3','dutch_sports_event','dutch_hol_fest']]
    Y = data[KPI]

    # Add a constant to the independent variables for OLS and logistic regression
    X_const = sm.add_constant(X)
 # OLS Regression
    X_train, X_test, Y_train, Y_test = train_test_split(X_const, Y, test_size=0.2, random_state=42)
    ols_model = sm.OLS(Y_train, X_train).fit()

    coeffs = pd.Series(ols_model.params, index=X.columns)
    if coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0:
            Shopping_reset_budget = budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend']+coeffs['ResetAfterDrinkSearch_branding_spend'])
            Reset_search_budget = budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend']+ coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])

    elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Shopping_reset_budget = min_ShoppingReset
            remaining_budget = budget - Shopping_reset_budget
            Reset_search_budget = remaining_budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = remaining_budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
    elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Reset_search_budget = min_ResetSearch
            remaining_budget = budget - Reset_search_budget
            Shopping_reset_budget = remaining_budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = remaining_budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
    elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            remaining_budget = budget - ResetAfterDrinkSearch_budget
            Shopping_reset_budget = remaining_budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'])
            Reset_search_budget = remaining_budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'])
    elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Reset_search_budget = min_ResetSearch
            Shopping_reset_budget = min_ShoppingReset
            ResetAfterDrinkSearch_budget = budget - Reset_search_budget - Shopping_reset_budget
    elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            Shopping_reset_budget = min_ShoppingReset
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            Reset_search_budget = budget - ResetAfterDrinkSearch_budget - Shopping_reset_budget
    elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            Reset_search_budget = min_ResetSearch
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            Shopping_reset_budget = budget - Reset_search_budget - ResetAfterDrinkSearch_budget
    else:
            Shopping_reset_budget = min_ShoppingReset
            Reset_search_budget = min_ResetSearch
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch

        # Ensure allocated budgets respect minimum budget constraints
    if Shopping_reset_budget < min_ShoppingReset:
            Shopping_reset_budget = min_ShoppingReset
    if Reset_search_budget < min_ResetSearch:
            Reset_search_budget = min_ResetSearch
    if ResetAfterDrinkSearch_budget < min_ResetAfterDrinkSearch:
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
    plt.figure(figsize=(10, 6))
    sns.barplot(x=[Shopping_reset_budget, Reset_search_budget, ResetAfterDrinkSearch_budget],
                y=['ShoppingReset_spend', 'ResetSearch_branding_spend', 'ResetAfterDrinkSearch_branding_spend'],
                palette="viridis")

    # Annotate the bars with the budget values
    for i, v in enumerate([Shopping_reset_budget, Reset_search_budget, ResetAfterDrinkSearch_budget]):
            plt.text(v + 0.01, i, f'{v:.2f}', color='black', ha='center', va='center')

    plt.title('Budget Allocation based on OLS Regression Coefficients')
    plt.xlabel('Allocated Budget')
    plt.ylabel('Campaigns')
    plt.show()
        # Random Forest Regressor
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)
    rf = RandomForestRegressor(n_estimators=100, random_state=42)
        #RandomizedSearchCV fine tuning
    n_estimators = [int(x) for x in np.linspace(start = 10, stop = 100, num = 10)]
    max_features = [i for i in range(1, 11)]
    max_features.append(None)
    max_depth = [int(x) for x in np.linspace(5, 20, num = 11)]
    max_depth.append(None)
    min_samples_split = [2, 5, 10, 15, 20, 25,30]
    min_samples_leaf = [5, 10, 20]
    bootstrap = [True, False]
    random_grid = {'n_estimators': n_estimators,
               'max_features': max_features,
               'max_depth': max_depth,
               'min_samples_split': min_samples_split,
               'min_samples_leaf': min_samples_leaf,
               'bootstrap': bootstrap}
    rscv = RandomizedSearchCV(estimator = rf, param_distributions = random_grid, n_iter = 100, cv = 3, verbose=2, random_state=42, n_jobs = -1)
    rscv.fit(X_train, Y_train)
    rf_rscv = rscv.best_estimator_
    Y_pred = rf_rscv.predict(X_test)

    mse = mean_squared_error(Y_test, Y_pred)
    from sklearn.metrics import r2_score
    r2_score = r2_score(Y_test, Y_pred)
    print(f"Random Forest Regressor MSE: {mse}")
    print(f"Random Forest Regressor R_2: {r2_score}")
    from sklearn.inspection import PartialDependenceDisplay
    fig, ax = plt.subplots(figsize=(20, 11),layout="compressed")
    ax.set_title("Random Forest Regressor")
    tree_disp = PartialDependenceDisplay.from_estimator(rf_rscv, X_train, ['ResetSearch_branding_spend','ResetAfterDrinkSearch_branding_spend','ShoppingReset_spend','quarter_1',
            'quarter_2', 'quarter_3','dutch_sports_event','dutch_hol_fest'], ax=ax, )
    return ols_model, rf_rscv, tree_disp

def build_model_lr_rf(data, KPI, budget, min_ResetSearch, min_ResetAfterDrinkSearch, min_ShoppingReset):
        import seaborn as sns
        X = data[['ResetSearch_branding_spend','ResetAfterDrinkSearch_branding_spend','ShoppingReset_spend','quarter_1',
            'quarter_2', 'quarter_3','dutch_sports_event','dutch_hol_fest']]
        Y = data[KPI]
   # Logistic Regression
        X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)
        logit_model = LogisticRegression()
        logit_model.fit(X_train, Y_train)
        log_reg_pred = logit_model.predict(X_test)
        log_reg_acc = accuracy_score(Y_test, log_reg_pred)
        # Check for positive coefficients and plot budget allocation
        coeffs = pd.Series(logit_model.coef_[0], index=X.columns)
        if coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0:
            Shopping_reset_budget = budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend']+coeffs['ResetAfterDrinkSearch_branding_spend'])
            Reset_search_budget = budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend']+ coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])

        elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Shopping_reset_budget = min_ShoppingReset
            remaining_budget = budget - Shopping_reset_budget
            Reset_search_budget = remaining_budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = remaining_budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ResetSearch_branding_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
        elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Reset_search_budget = min_ResetSearch
            remaining_budget = budget - Reset_search_budget
            Shopping_reset_budget = remaining_budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
            ResetAfterDrinkSearch_budget = remaining_budget * coeffs['ResetAfterDrinkSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetAfterDrinkSearch_branding_spend'])
        elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            remaining_budget = budget - ResetAfterDrinkSearch_budget
            Shopping_reset_budget = remaining_budget * coeffs['ShoppingReset_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'])
            Reset_search_budget = remaining_budget * coeffs['ResetSearch_branding_spend'] / (coeffs['ShoppingReset_spend'] + coeffs['ResetSearch_branding_spend'])
        elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] > 0):
            Reset_search_budget = min_ResetSearch
            Shopping_reset_budget = min_ShoppingReset
            ResetAfterDrinkSearch_budget = budget - Reset_search_budget - Shopping_reset_budget
        elif (coeffs['ShoppingReset_spend'] > 0 and coeffs['ResetSearch_branding_spend'] < 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            Shopping_reset_budget = min_ShoppingReset
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            Reset_search_budget = budget - ResetAfterDrinkSearch_budget - Shopping_reset_budget
        elif (coeffs['ShoppingReset_spend'] < 0 and coeffs['ResetSearch_branding_spend'] > 0 and coeffs['ResetAfterDrinkSearch_branding_spend'] < 0):
            Reset_search_budget = min_ResetSearch
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch
            Shopping_reset_budget = budget - Reset_search_budget - ResetAfterDrinkSearch_budget
        else:
            Shopping_reset_budget = min_ShoppingReset
            Reset_search_budget = min_ResetSearch
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch

        # Ensure allocated budgets respect minimum budget constraints
        if Shopping_reset_budget < min_ShoppingReset:
            Shopping_reset_budget = min_ShoppingReset
        if Reset_search_budget < min_ResetSearch:
            Reset_search_budget = min_ResetSearch
        if ResetAfterDrinkSearch_budget < min_ResetAfterDrinkSearch:
            ResetAfterDrinkSearch_budget = min_ResetAfterDrinkSearch

        plt.figure(figsize=(10, 6))
        sns.barplot(x=[Shopping_reset_budget, Reset_search_budget, ResetAfterDrinkSearch_budget],
                y=['ShoppingReset_spend', 'ResetSearch_branding_spend', 'ResetAfterDrinkSearch_branding_spend'],
                palette="viridis")

    # Annotate the bars with the budget values
        for i, v in enumerate([Shopping_reset_budget, Reset_search_budget, ResetAfterDrinkSearch_budget]):
            plt.text(v + 0.01, i, f'{v:.2f}', color='black', ha='center', va='center')

        plt.title('Budget Allocation based on OLS Regression Coefficients')
        plt.xlabel('Allocated Budget')
        plt.ylabel('Campaigns')
        plt.show()
        # Random Forest Classifier
        X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)
        rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        param_dist = {
           'n_estimators': [50, 100, 200, 500],
           'max_depth': [None, 10, 20, 30, 40, 50],
           'min_samples_split': [2, 5, 10],
           'min_samples_leaf': [1, 2, 4],
           'max_features': ['auto', 'sqrt', 'log2'],
           'bootstrap': [True, False]
        }
        rscv = RandomizedSearchCV(estimator = rf_classifier, param_distributions = param_dist, n_iter = 100, cv = 3, verbose=2, random_state=42, n_jobs = -1)
        rscv.fit(X_train, Y_train)
        rf_rscv = rscv.best_estimator_
        Y_pred = rf_rscv.predict(X_test)
        accuracy = accuracy_score(Y_test, Y_pred)

        from sklearn.inspection import PartialDependenceDisplay
        fig, ax = plt.subplots(figsize=(20, 11),layout="compressed")
        ax.set_title("Random Forest Regressor")
        tree_disp = PartialDependenceDisplay.from_estimator(rf_rscv, X_train, ['ResetSearch_branding_spend','ResetAfterDrinkSearch_branding_spend','ShoppingReset_spend','quarter_1',
            'quarter_2', 'quarter_3','dutch_sports_event','dutch_hol_fest'], ax=ax, )
        return logit_model, rf_rscv, tree_disp

def marketing_optimizer(pathname, target_date_sports, target_date_festival, KPI, budget, min_ResetSearch, min_ResetAfterDrinkSearch, min_ShoppingReset):
    data = data_reader(pathname)
    set_dummy_for_date(data, target_date_sports, target_date_festival)
    if KPI == 'engagedSessions_reset':
        ols_model, rf_rscv, _ = build_model_ols_rf(data, KPI, budget, min_ResetSearch, min_ResetAfterDrinkSearch, min_ShoppingReset)
    elif KPI == 'conversions_reset':
        logit_model, rf_rscv, _ = build_model_lr_rf(data, KPI, budget, min_ResetSearch, min_ResetAfterDrinkSearch, min_ShoppingReset)

mo = marketing_optimizer(pathname='dataset.csv', target_date_sports='2023-09-20', target_date_festival='2023-07-20',KPI='conversions_reset', budget=20,min_ResetSearch = 6, min_ResetAfterDrinkSearch=8, min_ShoppingReset=5)